# Ethereum Yellow Paper(技術詳細）の翻訳

- 元文献：https://ethereum.github.io/yellowpaper/paper.pdf
- レポジトリ: https://github.com/ethereum/yellowpaper

yellow paperは日々アップデートされているため、訳した時点と最新のものは内容が異なる可能性があります。

本翻訳は　"BYZANTIUM VERSION b7a4589 - 2018-02-07" を元にしている。


## Appendix B. Recursive Length Prefix(RLPエンコーディング)

```
*訳者注
Githubのwiki版(日本語訳）もある。
https://github.com/ethereum/wiki/wiki/%5BJapanese%5D-RLP
```

　これは、任意に構造化されたバイナリデータ（バイト配列:byte arrays）をエンコードするためのシリアライズ方法です。
　可能なデータ構造Tを以下のように定義します。



![](https://i.imgur.com/e3mCTrj.png)



　ここで、Oはバイトの集合です。 したがって、Bはすべてのバイト列の集合（またはバイト配列：ツリーとして想像した場合の葉にあたる）であり、Lは単一の葉ではないすべてのツリー状構造(ツリーとして想起される場合はブランチノード）です。Tはすべてのバイト配列とそのような構造化された配列の集合です。
　RLP関数は、2つのサブ関数を介してRLP関数として定義されます.1つは、値が単なるバイト配列の場合、２つ目は、シーケンスの場合です。
　

![](https://i.imgur.com/rtf6I36.png)

```
*訳者注

Bは配列の各要素に１バイト(0x00-0xff)を含む配列（byte-array)である。
B = [ff,9s,00,7f]

Lは配列の中に配列または1バイト値をネストしたデータ構造である。
L = [[02,33,78],[12,34],[22,33,44,dd]]

TはBまたはLを含む配列として定義される。

```

　シリアライズされる値がバイト配列の場合、RLPシリアライジングは次の3つの形式のいずれかをとります。
　　
- バイト配列が1バイトであり、その1バイトが128（2進数で0x10000000）未満の場合、入力は出力と正確に等しくなります。

```
*訳者注

0x10000000 は80であるため、各バイトは00 〜 7fの範囲である。 
例）b = [1d],[3a],[7f] 
```


- 配列に56バイト未満が含まれている場合、出力はバイト配列の長さに128を加えたバイト数で始まる入力に等しい。

```
*訳者注

x = [aa,b2,c4,5a,...] (56byte未満）

|x|を配列の長さ（バイト数）とすると
1 < |x| < 56　のとき、(128+|x|)を16進数に変換した値をプレフィックスとしてバイト列の先頭につける。

（例）|x|= 22の場合

128+22 = 150 (= 0x96)　なので

元のバイト列ｘの先頭に0x96を付加した配列　[96]・x
（または、x.shift(0x96）の結果生成される配列)

この場合の配列先頭の値は
0x80(128) 〜　0xb7(128+55) の間の値になる。

```


- それ以外の場合(56バイト以上の場合）、出力は、ビッグエンディアン整数として解釈されたときに入力バイト配列の長さに等しい最小長バイト配列の接頭辞の前にある入力に等しくなります。 この長さの値に183を加えて忠実にエンコードします。



```
*訳者注

原文がわかりずらいので解説する。

まず、いままでのバイト列は各要素が1バイトかつ、配列の長さが56未満である。
それ以上の場合、56以上のバイト数をエンコーディングする必要がある。

例として |x|=1000（要素数1000 = 1000バイトを含む配列）の場合にエンコーディングしてみる。

まず  |x|= 1000 = 0x3E8であるので

BE(|x|)=[03,E8] (ビッグエンディアンのため、大きい桁が左側にくる）

 (188)式はこれを表している。

次に|BE(|x|)| = |[03,E8]| = 2である。

よってエンコーディングは

Rb(x) = (183+2の16進数表記)・[0x02]・x
      =  [b9]・[02]・x 
（演算 ・ は配列を連結する）

また、この場合、配列の先頭はb8以上の16進数から始まる。
```

直列化される値がバイト配列の場合、RLP直列化は次の3つの形式のいずれかをとります。
 R<sub>b</sub>を以下の式で定義します。

　![](https://i.imgur.com/iWVfjiG.png)


　ここでBEは、正の整数値を最小の長さのビッグエンディアンバイト配列に変換し、ドット演算子は配列の連結を実行する演算子です。

```
*訳者注

以上をまとめると

先頭１バイトを見れば3通りのエンコーディングが区別できる

(1) 00 〜 7f: 1バイトの値そのまま
(2) 80 〜 b7:56バイト未満のバイト配列が続く
(3) b8以上: 続く1バイトが56バイト以上の配列の長さを示し、その後に情報を表すバイト列が続く

```

　代わりに、シリアライズされる値が配列のシーケンス（配列のネストなど）である場合、RLPシリアライズは2つの形式のうちの1つをとる。

- 各項目の連結シリアライズが56バイト未満の場合、出力は、このバイト配列の長さに192を加えたバイトでプレフィックスされた連結に等しくなります。

- それ以外の場合、出力は、ビッグエンディアン整数として解釈されるとき連結された直列化バイト配列の長さに等しい最小長のバイト配列がプレフィックスされた連結シリアル化に等しくなります。 この長さの値に247を忠実にエンコードする必要があります。

こうして、形式的にR<sub>l</sub>を定義します。：

![](https://i.imgur.com/WiJXCzJ.png)


```
*訳者注

例として、式(190)１段目の式に該当する場合のエンコーディングを示す。

配列　L = [[02,33,78],[12,34],[22,33,44,dd],[12]]

をRLPエンコードする場合、

s(x)を求める前に、入れ子になっている配列

x0=[02,33,78]
x1=[12,34]
x2=[22,33,44,dd]
x3=[12]

をそれぞれ b ∈　BとしてRLPエンコードする
それらをRLP(x0),RLP(x1),RLP(x2),RLP(x3)として表している。

式より
s(x)=RLP(x0)・RLP(x1)・RLP(x2)・RLP(x3)　（・は配列の連結を表す）

◯今回の配列Lの場合

RLP(x0)=[83,02,33,78]
RLP(x1)=[82,12,34]
RLP(x2)=[84,22,33,44,dd]
RLP(x3)=[12]
より

s(x) = [83,02,33,78,82,12,34,84,22,33,44,dd,12]

|s(x)| = 13  < 56より

Rl(x) = (192+13)・s(x)= [cd]・s(x) 
　　　 = [cd, 83,02,33,78,82,12,34,84,22,33,44,dd,12]

```

　RLPを使用して正の整数（PまたはPxに含まれる任意のx）として定義されたスカラー値をエンコードする場合、ビッグエンディアンの解釈が等しくなるように、最短バイトの配列として指定する必要があります。 したがって、正の整数iのRLPは、以下のように定義されます。
　
　![](https://i.imgur.com/Rq6Q9wo.png)
 
　RLPエンコードされたデータを解釈するとき、期待されるフラグメントがスカラー値としてデコードされ、先頭に0x00がバイト配列内に見つかった場合、それを非正規であるとみなし、無効なRLPデータと同様に扱い、完全に破棄する。
　符号付きまたは浮動小数点値の標準的なエンコード形式はありません。
　
　